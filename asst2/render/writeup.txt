15-418 Project 2
Names: Sam Russell (sarussel), Rob Waaser (rwaaser)

2. 
                size: 512x512               size: 1024x1024
                ref     cuda    (speedup)   ref     cuda    (speedup)
---------------------------------------------------------------------
rgb             1.94    0.24    (8.08x)     8.02    0.38    (21.11x)
rgby            1.05    0.22    (4.77x)     4.31    0.34    (12.68x)
pattern         4.32    0.31    (13.93x)    18.86   0.65    (29.02x)
rand10k         208.4   5.84    (35.68x)    882.7   17.0    (51.92x)
rand100k        2084.0  62.9    (33.13x)    8860.1  189.9   (46.66x)
snowsingle      255.5   5.59    (45.71x)    1006.3  13.8    (72.92x)

3. Decomposition
For our solution we use blocks of 256 threads.  Each block corresponds to a
Region of the image.  The number of blocks is thus a function of the width 
and height of the image.  Inside each block we decompose the problem into two 
phases.

Phase 1: Build a list of circles that overlap this region
         each thread gets assigned a subset of circles from the full list.
         threads check if their circles overlap the region using the provided
         circleInBox funciton, and if they do, they add them to a thread-private
         list.  After all threads have completed the private lists are combined 
         into a common list by using prefix sum to count the circles found by
         each thread, and (in parallel) copying the thread-private-lists into 
         a block-shared compact list

Phase 2: Iterate through the circle lists shading pixels
         each thread gets a small number of pixels and iterates through the
         circle list we built in phase 1 calling shade pixel for each circle.

4. Our solution uses only syncthread barriers and not atomics. Synchronization 
occurs in between Phase 1 and 2 of each block.  All threads
much finish building their private circle-list, then the prefix sum must be
called, and all thread must finish the prefix sum before they can start adding
their private lists to the block-list.  Finally all threads must finish adding
to the block list before they can move onto phase 2.  

5.  To reduce synchronization in Phase 1 we have threads build their
private lists first.  Then the prefix-sum allows threads to independently add
these private lists into a master lists by predefining unique index ranges.
Phase 2 is inherently independent due to pixel independence.  

6.  Throughout the process we used the CUDA profiler and various manual tests
to reason about our performance and possible improvements.

Our initial approach was just to implement phase 2.  We had 1 thread per
pixel and each thread checked all the circles.  This was obviously very slow
since we were checking alot of unnecessary circles and duplicating work. This 
led us to implement the two phase model described.  

We tried several different memory management strategies including dynamically 
allocating circle lists, or using a static 2d array, but found these to be slow
and use execessive memory.  We settled on the private list -> prefix sum -> master 
list as the fastest and most memory efficient.  

Finally we tweaked some parameters (including the number of pixels per thread in 
Phase 2, and the order or circle/pixel work being chuncked or interleaved) to 
obtain maximum performance. These modifications allowed us to take advantage
of maximum chache similarity and minimize warp divergence
